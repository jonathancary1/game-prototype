using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class LinearPath
{
    /// <summary>
    /// Mesh returns a mesh of the path traced out by a perpendicular line-segment with length size along path.
    /// </summary>
    public static (Vector2[], int[]) Mesh(Vector2[] path, float size)
    {
        Vector2[] vertices = Vertices(path, size).ToArray();
        return (vertices, Triangles(vertices.Length).ToArray());
    }

    /// <summary>
    /// Mesh returns a mesh of the path traced out by a perpendicular line-segment with width size along path.
    /// The parameter plane applies an affine transformation to each vertex of the mesh.
    /// </summary>
    public static (Vector3[], int[]) Mesh(Vector2[] path, float size, Plane plane)
    {
        Vector3[] vertices = Vertices(path, size).Select(plane.Map).ToArray();
        return (vertices, Triangles(vertices.Length).ToArray());
    }

    /// <summary>
    /// Mesh returns a mesh of the path traced out by a perpendicular line-segment with width size along path.
    /// The parameter plane applies an affine transformation to each vertex of the mesh.
    /// The parameters minimum and maximum offset and add thickness to the mesh.
    /// </summary>
    public static (Vector3[], int[]) Mesh(Vector2[] path, float size, Plane plane, float minimum, float maximum)
    {
        var mesh = Mesh(path, size, plane);

        List<Vector3> vertices = new List<Vector3>();
        vertices.AddRange(mesh.Item1.Select(vertex => vertex + minimum * plane.Normal));
        vertices.AddRange(mesh.Item1.Select(vertex => vertex + maximum * plane.Normal));

        List<int> triangles = new List<int>();
        triangles.AddRange(mesh.Item2);
        triangles.AddRange(Shuffle(mesh.Item2.Select(i => i + mesh.Item1.Length)));
        triangles.AddRange(Sides(mesh.Item1.Length));
        triangles.AddRange(Caps(mesh.Item1.Length));

        return (vertices.ToArray(), triangles.ToArray());
    }

    /// <summary>
    /// Vertices returns the vertices of a linear path.
    /// </summary>
    private static IEnumerable<Vector2> Vertices(Vector2[] path, float size)
    {
        path = Filter(path).ToArray();

        if (path.Length < 2)
        {
            yield break;
        }

        {
            Vector2 a = path[0];
            Vector2 b = path[1];

            Vector2 ab = 0.5f * size * Vector2.Perpendicular(b - a).normalized;

            yield return a + ab;
            yield return a - ab;
        }

        for (int i = 1; i < path.Length - 1; i++)
        {
            var (a, b, c) = (path[i - 1], path[i], path[i + 1]);

            Vector2 ab = 0.5f * size * Vector2.Perpendicular(b - a).normalized;
            Vector2 bc = 0.5f * size * Vector2.Perpendicular(c - b).normalized;

            Vector2 intersection = Geometry.LineIntersection((a + ab, b + ab), (b + bc, c + bc)) ?? (b + ab);

            yield return intersection;
            yield return b - (intersection - b);
        }

        {
            Vector2 a = path[path.Length - 2];
            Vector2 b = path[path.Length - 1];

            Vector2 ab = 0.5f * size * Vector2.Perpendicular(b - a).normalized;

            yield return b + ab;
            yield return b - ab;
        }
    }

    /// <summary>
    /// Triangles returns the indices for a linear path generated by Vertices.
    /// </summary>
    private static IEnumerable<int> Triangles(int length)
    {
        for (int i = 0; i < length - 2; i += 2)
        {
            yield return i;
            yield return i + 2;
            yield return i + 1;

            yield return i + 1;
            yield return i + 2;
            yield return i + 3;
        }
    }

    /// <summary>
    /// Sides returns the indicies for the faces along the two sides of a thickened linear path.
    /// </summary>
    private static IEnumerable<int> Sides(int length)
    {
        for (int i = 0; i < length - 2; i += 2)
        {
            yield return i;
            yield return i + length;
            yield return i + 2;

            yield return i + length;
            yield return i + 2 + length;
            yield return i + 2;

            yield return i + 1;
            yield return i + 3;
            yield return i + 1 + length;

            yield return i + 1 + length;
            yield return i + 3;
            yield return i + 3 + length;
        }
    }

    /// <summary>
    /// Caps returns the indices for the four faces at the beginning and end of a thickened linear path. 
    /// </summary>
    private static IEnumerable<int> Caps(int length)
    {
        yield return 0;
        yield return 1;
        yield return length;

        yield return length;
        yield return 1;
        yield return length + 1;

        yield return length - 2;
        yield return length - 2 + length;
        yield return length - 1;

        yield return length - 2 + length;
        yield return length - 1 + length;
        yield return length - 1;
    }

    /// <summary>
    /// Given an enumerator of indices, Shuffle reverses each face.
    /// </summary>
    private static IEnumerable<int> Shuffle(IEnumerable<int> triangles)
    {
        using (IEnumerator<int> enumerator = triangles.GetEnumerator())
        {
            int[] face;

            while ((face = Utilities.Take(enumerator, 3)).Length == 3)
            {
                yield return face[0];
                yield return face[2];
                yield return face[1];
            }
        }
    }

    /// <summary>
    /// Filter filters any vertices equal to their prior neighboring vertex.
    /// This guarantees that each pair of neighboring vertices have a well defined perpendicular.
    /// </summary>
    private static IEnumerable<Vector2> Filter(Vector2[] path)
    {
        if (path.Length > 0)
        {
            yield return path[0];
        }

        for (int i = 1; i < path.Length; i++)
        {
            if (path[i - 1] != path[i])
            {
                yield return path[i];
            }
        }
    }
}
